import os
import sys
from lexer import Lexer
from parser import Parser
from ast import ASTNode
import json

class Compiler:
    """
    Compiler for SypherLang that transforms .sypher source code into executable bytecode.
    It uses a lexer and parser to convert human-readable code into intermediate bytecode.
    """

    def __init__(self):
        self.output_directory = "./bytecode/"
        if not os.path.exists(self.output_directory):
            os.makedirs(self.output_directory)

    def compile(self, input_file):
        """
        Compile a .sypher source code file into intermediate bytecode.
        
        :param input_file: Path to the .sypher source code file.
        :return: None
        """
        try:
            with open(input_file, 'r') as source_code:
                code = source_code.read()
                print(f"[Compiler] Reading source code from {input_file}")

            lexer = Lexer()
            tokens = lexer.tokenize(code)
            print(f"[Compiler] Tokens generated: {tokens}")

            parser = Parser()
            ast_root = parser.parse(tokens)
            print(f"[Compiler] AST generated: {ast_root}")

            bytecode = self.generate_bytecode(ast_root)
            self.write_bytecode(input_file, bytecode)

        except FileNotFoundError:
            print(f"[Compiler] Error: File {input_file} not found.")
        except Exception as e:
            print(f"[Compiler] Error during compilation: {str(e)}")

    def generate_bytecode(self, ast_root):
        """
        Generate bytecode from the Abstract Syntax Tree (AST).
        
        :param ast_root: Root of the AST.
        :return: A list representing bytecode.
        """
        print(f"[Compiler] Generating bytecode from AST...")
        bytecode = []
        self.traverse_ast(ast_root, bytecode)
        return bytecode

    def traverse_ast(self, node, bytecode):
        """
        Traverse the AST to generate bytecode instructions.
        
        :param node: The current AST node.
        :param bytecode: The list storing the generated bytecode.
        """
        if node is None:
            return

        if node.type == 'assignment':
            # Example: x = 5
            bytecode.append({'op': 'LOAD_CONST', 'value': node.value})
            bytecode.append({'op': 'STORE_NAME', 'name': node.name})

        elif node.type == 'expression':
            # Example: 5 + 2
            self.traverse_ast(node.left, bytecode)
            self.traverse_ast(node.right, bytecode)
            bytecode.append({'op': 'BINARY_OP', 'operation': node.operator})

        elif node.type == 'function_call':
            # Example: encrypt(data)
            bytecode.append({'op': 'CALL_FUNCTION', 'name': node.function_name, 'args': node.args})

        elif node.type == 'control_flow':
            # Example: if, while, for loops
            bytecode.append({'op': 'CONTROL_FLOW', 'condition': node.condition})
            for sub_node in node.body:
                self.traverse_ast(sub_node, bytecode)

        elif node.type == 'quantum_op':
            # Example: Lattice-based encryption
            bytecode.append({'op': 'QUANTUM_ENCRYPT', 'data': node.data})
        
        elif node.type == 'privacy_contract':
            # Example: PrivacyContract (compile privacy-based smart contract logic)
            bytecode.append({'op': 'PRIVACY_CONTRACT', 'contract': node.contract})
        
        elif node.type == 'parallel_exec':
            # Example: Parallel execution of different functions
            bytecode.append({'op': 'PARALLEL_EXEC', 'tasks': node.tasks})

        print(f"[Compiler] Traversing node: {node.type}")
        
    def write_bytecode(self, input_file, bytecode):
        """
        Write the generated bytecode to a file in the output directory.
        
        :param input_file: The input source file name.
        :param bytecode: The bytecode to be written to the file.
        """
        base_filename = os.path.basename(input_file)
        output_file = os.path.join(self.output_directory, f"{base_filename}.bytecode.json")
        
        with open(output_file, 'w') as out:
            json.dump(bytecode, out, indent=4)
            print(f"[Compiler] Bytecode written to {output_file}")

# Entry Point for the Compiler
if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python compiler.py <source_file>")
    else:
        compiler = Compiler()
        source_file = sys.argv[1]
        compiler.compile(source_file)
